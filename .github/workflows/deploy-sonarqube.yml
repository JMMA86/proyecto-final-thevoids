name: Deploy SonarQube to Azure

on:
  push:
    branches: [main]
    paths:
      - "**.tf"
      - "**.yml"
      - ".github/workflows/**"
  workflow_dispatch:
    inputs:
      destroy_infrastructure:
        description: "Destruir infraestructura existente"
        required: false
        default: "false"
        type: choice
        options:
          - "false"
          - "true"
      force_recreate:
        description: "Forzar recreaciÃ³n de recursos existentes"
        required: false
        default: "false"
        type: choice
        options:
          - "false"
          - "true"

env:
  TF_VERSION: "1.6.0"
  ANSIBLE_VERSION: "2.15"

jobs:
  deploy:
    name: Deploy Infrastructure and Configure SonarQube
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Setup Python for Ansible
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible
          pip install azure-cli

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Terraform variables file
        run: |
          cat > deploy/terraform/terraform.tfvars << EOF
          subscription_id     = "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          resource_group_name = "${{ vars.RESOURCE_GROUP_NAME || 'rg-sonarqube-chile' }}"
          location            = "${{ vars.AZURE_LOCATION || 'Chile Central' }}"
          vm_size             = "${{ vars.VM_SIZE || 'Standard_B2s' }}"
          admin_username      = "${{ vars.ADMIN_USERNAME || 'azureuser' }}"
          admin_password      = "${{ secrets.ADMIN_PASSWORD }}"
          allowed_cidr        = "${{ vars.ALLOWED_CIDR || '0.0.0.0/0' }}"
          environment         = "${{ vars.ENVIRONMENT || 'production' }}"
          EOF

      - name: Terraform Format Check
        run: |
          cd deploy/terraform
          terraform fmt -check=true -diff=true

      - name: Terraform Init
        run: |
          cd deploy/terraform
          terraform init

      - name: Terraform Validate
        run: |
          cd deploy/terraform
          terraform validate

      - name: Handle existing resources
        run: |
          cd deploy/terraform

          if [ "${{ github.event.inputs.force_recreate }}" = "true" ]; then
            echo "ðŸ”¥ Force recreate enabled - removing existing resources..."
            
            # Eliminar recursos existentes con Azure CLI
            RG_EXISTS=$(az group exists --name "${{ vars.RESOURCE_GROUP_NAME || 'rg-sonarqube-chile' }}" --output tsv)
            if [ "$RG_EXISTS" = "true" ]; then
              echo "Deleting existing resource group..."
              az group delete --name "${{ vars.RESOURCE_GROUP_NAME || 'rg-sonarqube-chile' }}" --yes --no-wait
              
              # Esperar a que se complete la eliminaciÃ³n
              echo "Waiting for resource group deletion to complete..."
              while az group exists --name "${{ vars.RESOURCE_GROUP_NAME || 'rg-sonarqube-chile' }}" --output tsv | grep -q "true"; do
                echo "Still deleting... waiting 30 seconds"
                sleep 30
              done
              echo "âœ… Resource group deleted successfully"
            fi
          else
            echo "ðŸ”„ Attempting to import existing resources..."
            RG_NAME="${{ vars.RESOURCE_GROUP_NAME || 'rg-sonarqube-chile' }}"
            SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            
            # FunciÃ³n para importar recurso si existe
            import_resource() {
              local resource_type="$1"
              local resource_name="$2"
              local terraform_resource="$3"
              local resource_id="$4"
              
              if [ ! -z "$resource_id" ] && [ "$resource_id" != "null" ]; then
                echo "Importing $resource_type '$resource_name'..."
                terraform import "$terraform_resource" "$resource_id" || echo "Import failed or resource already in state"
              fi
            }
            
            # Resource Group
            RG_EXISTS=$(az group exists --name "$RG_NAME" --output tsv)
            if [ "$RG_EXISTS" = "true" ]; then
              import_resource "Resource Group" "$RG_NAME" "azurerm_resource_group.main" "/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RG_NAME"
            fi
            
            # Virtual Network
            VNET_ID=$(az network vnet show --resource-group "$RG_NAME" --name "vnet-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            import_resource "Virtual Network" "vnet-sonarqube" "azurerm_virtual_network.main" "$VNET_ID"
            
            # Subnet
            SUBNET_ID=$(az network vnet subnet show --resource-group "$RG_NAME" --vnet-name "vnet-sonarqube" --name "internal" --query "id" --output tsv 2>/dev/null || echo "")
            import_resource "Subnet" "internal" "azurerm_subnet.internal" "$SUBNET_ID"
            
            # Network Security Group
            NSG_ID=$(az network nsg show --resource-group "$RG_NAME" --name "nsg-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            import_resource "Network Security Group" "nsg-sonarqube" "azurerm_network_security_group.main" "$NSG_ID"
            
            # Public IP
            PIP_ID=$(az network public-ip show --resource-group "$RG_NAME" --name "pip-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            import_resource "Public IP" "pip-sonarqube" "azurerm_public_ip.main" "$PIP_ID"
            
            # Network Interface
            NIC_ID=$(az network nic show --resource-group "$RG_NAME" --name "nic-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            import_resource "Network Interface" "nic-sonarqube" "azurerm_network_interface.main" "$NIC_ID"
            
            # Network Interface Security Group Association
            if [ ! -z "$NIC_ID" ] && [ ! -z "$NSG_ID" ]; then
              ASSOC_ID="${NIC_ID}|${NSG_ID}"
              import_resource "NIC-NSG Association" "nic-nsg-association" "azurerm_network_interface_security_group_association.main" "$ASSOC_ID"
            fi
            
            # Virtual Machine
            VM_ID=$(az vm show --resource-group "$RG_NAME" --name "vm-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            import_resource "Virtual Machine" "vm-sonarqube" "azurerm_linux_virtual_machine.main" "$VM_ID"
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        continue-on-error: true

      - name: Terraform Plan
        run: |
          cd deploy/terraform
          terraform plan -out=tfplan
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

      - name: Terraform Destroy (if requested)
        if: github.event.inputs.destroy_infrastructure == 'true'
        run: |
          echo "ðŸ”¥ Destruyendo infraestructura existente..."
          cd deploy/terraform
          terraform destroy -auto-approve
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

      - name: Terraform Apply
        if: github.event.inputs.destroy_infrastructure != 'true'
        run: |
          cd deploy/terraform

          # Intentar aplicar el plan
          if ! terraform apply -auto-approve tfplan; then
            echo "âŒ Apply failed, possibly due to resource conflicts"
            echo "ðŸ”„ Attempting to resolve conflicts and retry..."
            
            # Importar recursos que pueden estar causando conflictos
            RG_NAME="${{ vars.RESOURCE_GROUP_NAME || 'rg-sonarqube-chile' }}"
            SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            
            # Intentar importar recursos que falten despuÃ©s del primer fallo
            echo "Attempting to import additional resources..."
            
            # Virtual Network
            VNET_ID=$(az network vnet show --resource-group "$RG_NAME" --name "vnet-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            if [ ! -z "$VNET_ID" ]; then
              terraform import azurerm_virtual_network.main "$VNET_ID" 2>/dev/null || echo "VNET import skipped"
            fi
            
            # Network Security Group
            NSG_ID=$(az network nsg show --resource-group "$RG_NAME" --name "nsg-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            if [ ! -z "$NSG_ID" ]; then
              terraform import azurerm_network_security_group.main "$NSG_ID" 2>/dev/null || echo "NSG import skipped"
            fi
            
            # Subnet
            SUBNET_ID=$(az network vnet subnet show --resource-group "$RG_NAME" --vnet-name "vnet-sonarqube" --name "internal" --query "id" --output tsv 2>/dev/null || echo "")
            if [ ! -z "$SUBNET_ID" ]; then
              terraform import azurerm_subnet.internal "$SUBNET_ID" 2>/dev/null || echo "Subnet import skipped"
            fi
            
            # Network Interface
            NIC_ID=$(az network nic show --resource-group "$RG_NAME" --name "nic-sonarqube" --query "id" --output tsv 2>/dev/null || echo "")
            if [ ! -z "$NIC_ID" ]; then
              terraform import azurerm_network_interface.main "$NIC_ID" 2>/dev/null || echo "NIC import skipped"
            fi
            
            # Refresh state y planificar nuevamente
            terraform refresh
            terraform plan -out=tfplan-retry
            
            # Segundo intento de aplicaciÃ³n
            if ! terraform apply -auto-approve tfplan-retry; then
              echo "âŒ Second apply attempt failed"
              echo "ðŸ” Checking current state..."
              terraform state list
              exit 1
            fi
          fi
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

      - name: Get Terraform Outputs
        if: github.event.inputs.destroy_infrastructure != 'true'
        id: terraform_outputs
        run: |
          cd deploy/terraform
          echo "public_ip=$(terraform output -raw public_ip_address)" >> $GITHUB_OUTPUT
          echo "sonarqube_url=$(terraform output -raw sonarqube_url)" >> $GITHUB_OUTPUT
          echo "ssh_command=$(terraform output -raw ssh_connection_command)" >> $GITHUB_OUTPUT

          # Guardar clave SSH privada
          terraform output -raw ssh_private_key > ../../deploy/ansible/ssh_key.pem
          chmod 600 ../../deploy/ansible/ssh_key.pem

      - name: Create Ansible Inventory
        if: github.event.inputs.destroy_infrastructure != 'true'
        run: |
          cat > deploy/ansible/inventory.yml << EOF
          all:
            hosts:
              sonarqube-vm:
                ansible_host: ${{ steps.terraform_outputs.outputs.public_ip }}
                ansible_user: ${{ vars.ADMIN_USERNAME || 'azureuser' }}
                ansible_ssh_private_key_file: ./ssh_key.pem
                ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
                ansible_python_interpreter: /usr/bin/python3
          EOF

      - name: Wait for VM to be ready
        if: github.event.inputs.destroy_infrastructure != 'true'
        run: |
          echo "Esperando que la VM estÃ© lista..."
          for i in {1..20}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i deploy/ansible/ssh_key.pem ${{ vars.ADMIN_USERNAME || 'azureuser' }}@${{ steps.terraform_outputs.outputs.public_ip }} "echo 'VM ready'"; then
              echo "VM estÃ¡ lista!"
              break
            fi
            echo "Intento $i/20 - esperando 30 segundos..."
            sleep 30
          done

      - name: Run Ansible Playbook
        if: github.event.inputs.destroy_infrastructure != 'true'
        run: |
          cd deploy/ansible
          ansible-playbook -i inventory.yml configure-sonarqube.yml -v
        env:
          ANSIBLE_HOST_KEY_CHECKING: false

      - name: Verify SonarQube is running
        if: github.event.inputs.destroy_infrastructure != 'true'
        run: |
          echo "Verificando que SonarQube estÃ© disponible..."
          for i in {1..10}; do
            if curl -f -s "${{ steps.terraform_outputs.outputs.sonarqube_url }}/api/system/status" | grep -q "UP"; then
              echo "âœ… SonarQube estÃ¡ funcionando correctamente!"
              break
            fi
            echo "Intento $i/10 - esperando 60 segundos..."
            sleep 60
          done

      - name: Display Deployment Information
        if: github.event.inputs.destroy_infrastructure != 'true'
        run: |
          echo "ðŸŽ‰ Despliegue completado exitosamente!"
          echo "=================================="
          echo "SonarQube URL: ${{ steps.terraform_outputs.outputs.sonarqube_url }}"
          echo "SSH Command: ${{ steps.terraform_outputs.outputs.ssh_command }}"
          echo "Credenciales por defecto:"
          echo "  Usuario: admin"
          echo "  ContraseÃ±a: admin"
          echo ""
          echo "La infraestructura estÃ¡ lista para usar!"

      - name: Save deployment outputs
        if: github.event.inputs.destroy_infrastructure != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: |
            deploy/terraform/terraform.tfstate
            deploy/ansible/inventory.yml
          retention-days: 30

  cleanup:
    name: Cleanup temporary files
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
      - name: Remove sensitive files
        run: |
          echo "Limpieza completada"
